---
title: "Analyzing GeoMx NGS Data with GeomxTools"
author: "David Henderson, Nicole Ortogero, Zhi Yang, Rona Vitancol, Maddy Griswold"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    toc: true
vignette: >
  %\VignetteIndexEntry{Analyzing GeoMx NGS Data with GeomxTools}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
    
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 5,
  fig.height = 4,
  dpi=200
)
```

## Introduction

Basic task when analyzing GeoMx NGS dataset outside the Digital Spatial Profiling Data Analysis (DSPDA) is to read the DCC files, PKC files, annotation file and  convert them to an object that allows user to perform their own analysis. 

GeomxTools gives users the capability to read these GeoMx output (DCC, PKC and annotation file) and convert them to NanoStringGeoMxSet, flag samples and probes that is below or above thresholds for quality control, remove samples or probes that are flagged.

### Dataset Introduction
For this demo analysis, we will use the kidney dataset that can be found here:

NanoString GeoMx DSP dataset of diabetic kidney disease (DKD) vs healthy kidney tissue. 

Seven slides were analyzed, 4 DKD and 3 healthy. Regions of Interest (ROI) were focused two different parts of a kidneyâ€™s structure: tubules or glomeruli. One glomerulus ROI contains the entirety of a glomerulus. Individual glomeruli were identified by a pathologist as either behaving relatively healthy or diseased regardless on if the tissue was DKD or healthy. Tubule ROIs were segmented into distal (PanCK) and proximal (neg) tubules. While both distal and proximal tubules are called tubules, they perform very different functions in the kidney. Segmented areas of an ROI are called Areas of Interest (AOI).


## Setting up GeomxTools and related packages

First step in using the GeomxTools package is to install the package and invoke the library command to load it into the current session.

```{r libs, message=FALSE, warning=FALSE }
# If you have not done so, install devtools to install needed R packages

# install.packages("devtools")
# devtools::install_github("Nanostring-Biostats/GeomxTools", ref = "dev")
# devtools::install_github("Nanostring-Biostats/NanoStringNCTools")

library(NanoStringNCTools)
library(GeomxTools, lib.loc = "/usr/local/lib/R/site-library" )
library(EnvStats)
library(ggiraph)
```

## Load DCC files, PKC files and annotation file
Next step is to load the DCC, PKC and annotation file. 
- Save your PKC and annotation files in one folder, in this example, it is 
stored in kidney_demo 
- Save your DCC files as a sub-folder of the above for easy access, in this example, 
it is stored in kidney_demo/DCC_files. 
- Copy the folder path as your datadir below and change the slash to backslash. 

```{r quickstart, message=FALSE, warning=FALSE}
datadir <- file.path( "/home/rstudio/NAS_data/rvitancol/kidney_demo")
DCCFiles <- list.files(file.path( datadir , "DCC_files"), pattern=".dcc$", full.names=TRUE)
PKCFiles <- list.files(file.path(datadir), pattern=".pkc$", full.names=TRUE)
SampleAnnotationFile <- file.path(datadir, "kidney_demo_AOI_Annotations.xlsx")

demoData <-
  suppressWarnings(readNanoStringGeoMxSet(dccFiles = DCCFiles,
                                          pkcFiles = PKCFiles,
                                          phenoDataFile = SampleAnnotationFile,
                                          phenoDataSheet = "Template",
                                          phenoDataDccColName = "Sample_ID",
                                          protocolDataColNames = c("aoi", 
                                                                   "roi"),
                                          experimentDataColNames = c("panel",
                                                                     "instrument_type")))

#Shift counts to one to mimic how DSPDA handles zero counts
demoData <- shiftCountsOne(demoData, elt="exprs", useDALogic=TRUE) 
```

### Checking the NanoStringGeoMxSet object
For users most familiar with the structure of files in DSPDA, this is how you 
can extract your initial dataset from the object as a data frame. 
You can then save it to a csv file if you need to.

```{r countmatrix, eval = FALSE}
segmentProperties <- sData(demoData)
head(segmentProperties)
BioProbeCountMatrix <- exprs(demoData)
head(BioProbeCountMatrix)
# write.csv(BioProbeCountMatrix, "Bioprobe_count_matrix.csv")


head(assayData(demoData)[["exprs"]])
head( pData( demoData ), 2 )
protocolData( demoData )
svarLabels( demoData )
```

## Quality Control Assessment

Users can flag samples that fail QC thresholds based on expression. This is similar to QC in DSPDA. 

Note that GeoDiff R package, a bayesian model based data analysis package is 
currently under development and planned to be released. This will include quality 
control functions based on score test, AOI QC as well as differential expression analysis. 

### Technical Signal QC 

##### Set Sequencing QC flags using default settings from DSPDA

Use the setSeqQCFlags  function to set Sequencing QC Flags to your dataset.

```{r setseqqcflag,  eval = TRUE}
demoData <- setSeqQCFlags(demoData, 
                          qcCutoffs=list(minSegmentReads=1000, 
                                 percentAligned=80, 
                                 percentSaturation=50))
```

##### Check Results

```{r checkseqqcflag,  eval = TRUE}
head(protocolData(demoData)[["QCFlags"]])

prData <- protocolData(demoData)
QCResults <- prData[["QCFlags"]]
QCResults <- as.data.frame(QCResults)

# Check which samples have low reads
LowReads <- subset(demoData, select= prData[["QCFlags"]][,"LowReads"] == TRUE)
sData(LowReads)["Raw"]

# Check which samples have low percent Trimmed
LowTrimmed <- subset(demoData, select= prData[["QCFlags"]]
                     [,"LowTrimmed"] == TRUE)
sData(LowTrimmed)[c("Trimmed", "Raw", "Trimmed (%)")]

# Check which samples have low percent Stitched
LowStitched <- subset(demoData, select= prData[["QCFlags"]]
                      [,"LowStitched"] == TRUE)
sData(LowStitched)[c("Stitched", "Stitched (%)")]

# Check which samples are below Sequencing Saturation cutoff
LowSaturation <- subset(demoData, select= prData[["QCFlags"]][,"LowSaturation"] == TRUE)
head(sData(LowSaturation)[c("DeduplicatedReads", "Aligned", "Saturated (%)")])

# Check which samples are below percent Aligned cutoff
LowAligned <- subset(demoData, select= prData[["QCFlags"]][,"LowAligned"] == TRUE)
head(sData(LowAligned)[c("Raw", "Aligned", "Aligned (%)")])

# Append relevant variables to the the QC results dataframe. 
QCResults <- cbind(QCResults, sData(demoData)[c( "Raw", "Trimmed", "Trimmed (%)",
                                                 "DeduplicatedReads", "Saturated (%)",
                                                 "Aligned", "Aligned (%)",  "Stitched",
                                                 "Stitched (%)")])
head(QCResults)
```

Other columns that are available in the NanoStringGeoMxSet that can easily be added to your 
data frame can be accessed by using sData accessor function.You can add any columns here in your QC Results

```{r callsdata,  eval = TRUE}
names(sData(demoData))

# add as additional column to your QCResults, say you want to add scan name, 
# roi, aoi and slide name to your QC results
QCResults <- cbind(QCResults, sData(demoData)[c("aoi", "roi", "slide name")])

```


##### Update cutoffs for Sequencing QC
If needed, you can set the threshold for sequencing cutoff. And repeat checking of the QC flags steps above. Here we set the percentAligned to 75.

```{r setqcflagupdated,  eval = TRUE}
demoData <- setSeqQCFlags(demoData, 
                       qcCutoffs=list(minSegmentReads=1000,
                                      percentAligned=75,
                                      percentSaturation=60))
```


#####  Exclude samples that did not pass Sequencing QC

```{r excludeseq,  eval = TRUE}
QCResultsIndex <- which(apply(protocolData(demoData)[["QCFlags"]], 1L , 
                              function(x) sum(x) == 0L))
QCPassed <- demoData[, QCResultsIndex]
dim(QCPassed) 
```


### Technical background QC 

##### Set Background QC flags using default settings from DSPDA

Use the setBackgroundQCFlags function to set background QC Flags to your dataset.
Not that LowNegatives and HighNTC flags are added to your protocolData


```{r setbgqcflag,  eval = TRUE}
demoData <- setBackgroundQCFlags(demoData, 
                                 qcCutoffs=list(minNegativeCount=10, 
                                 maxNTCCount=60))
```

##### Check Results

```{r checkbgqcflag}
head(protocolData(demoData)[["QCFlags"]])

prData <- protocolData(demoData)
QCResults <- prData[["QCFlags"]]
QCResults <- as.data.frame(QCResults)

#Flag sample as PASS or WARNING if sample has a QC flag
QCResults$QCStatus <- apply(prData[["QCFlags"]], 1L, function(x) {
        y <- sum(x) == 0L
        y <- ifelse(y, "PASS", "WARNING")
        return(y)
    })

# Append relevant variables to the the QC results dataframe
QCResults <- cbind(QCResults, sData(demoData)[c("NegGeoMean", "NTC")])
head(QCResults[which(QCResults$QCStatus == "WARNING"),])

# Check which samples have low negative geomean
LowNegatives <- subset(demoData, select= prData[["QCFlags"]]
                       [,"LowNegatives"] == TRUE)
head(sampleNames(phenoData(LowNegatives)))

# Check which samples have high NTC
HighNTC <- subset(demoData, select= prData[["QCFlags"]][,"HighNTC"] == TRUE)
head(sampleNames(phenoData(HighNTC)))
```

##### Update cutoffs for background QC

```{r setbgqcflagupdated,  eval = TRUE}
demoData <- setBackgroundQCFlags(demoData, 
                  qcCutoffs=list(minNegativeCount=5,  
                                 maxNTCCount=8000))
```

#####  Exclude samples that did not pass Background and Sequencing QC

```{r excludebg_seq}
# Subset object to exclude all that did not pass Sequencing and background QC
QCResultsIndex <- which(apply(protocolData(demoData)[["QCFlags"]], 1L , 
                              function(x) sum(x) == 0L))
QCPassed <- demoData[, QCResultsIndex]
dim(QCPassed) 
```

#####  Exclude samples that did not pass just the Background QC

```{r excludebg_only}
# Subset object to exclude those that did not pass just the background QC
QCResultsIndex <- which(apply(protocolData(demoData)[["QCFlags"]]
                              [, c("HighNTC", "LowNegatives")], 
                              1L , function(x) sum(x) == 0L))
QCPassed <- demoData[,QCResultsIndex]
dim(QCPassed) 
```



### Segment QC

##### DSP Parameters Minimum Nuclei and Surface Area Count QC  

Set Segment QC flags using default settings from DSPDA
Use the setGeoMxQCFlags function to set segment QC Flags to your dataset.

```{r setsegmentqcflag,  eval = TRUE}
demoData <- setGeoMxQCFlags(demoData, 
                            qcCutoffs=list(minNuclei=16000,
                                           minArea=20))
```

##### Check Results

```{r checksegqcflag}
#Check Results
head(protocolData(demoData)[["QCFlags"]])

prData <- protocolData(demoData)
QCResults <- prData[["QCFlags"]]
QCResults <- as.data.frame(QCResults)

#Flag sample as PASS or WARNING if sample has a QC flag
QCResults$QCStatus <- apply(prData[["QCFlags"]], 1L, function(x) {
        y <- sum(x) == 0L
        y <- ifelse(y, "PASS", "WARNING")
        return(y)
    })

# Check which samples have low area
LowArea <- subset(demoData, select= prData[["QCFlags"]][,"LowArea"]== TRUE)
head(sData(LowArea)["area"])

# Check which samples have low nuclei
LowNuclei <- subset(demoData, select= prData[["QCFlags"]][,"LowNuclei"]== TRUE)
head(sData(LowNuclei)["nuclei"])

# Append relevant variables to the the QC results dataframe
QCResults <- cbind(QCResults, sData(demoData)[c("area", "nuclei")])
head(QCResults[which(QCResults$QCStatus == "WARNING"),])

```

##### Update cutoffs for Segment QC

If needed, you can set the threshold for minimum area and minimum nuclei cutoff. 
Repeat checking of the QC flags steps above if needed. For this one, maybe 
update the minimum nuclei to 15000


```{r setsegmentqcflagupdated,  eval = TRUE}
demoData <- setGeoMxQCFlags(demoData, 
                            qcCutoffs=list(minNuclei=15000, 
                                           minArea=20))
```

##### Exclude samples that did not pass QC

```{r}
# Subset object to exclude all samples that did not pass QC
QCResultsIndex <- which(apply(protocolData(demoData)[["QCFlags"]], 1L , 
                              function(x) sum(x) == 0L))
QCPassed <- demoData[, QCResultsIndex]
dim(QCPassed) 
```

#####  Exclude samples that did not pass just the segment QC

```{r excludesegment_only}
# Subset object to exclude those that did not pass just the segment QC
QCResultsIndex <- which(apply(protocolData(demoData)[["QCFlags"]]
                              [, c("LowArea", "LowNuclei")], 1L , 
                              function(x) sum(x) == 0L))
QCPassed <- demoData[,QCResultsIndex]
dim(QCPassed) 
```


### Biological Probe QC 

Use the setBioProbeQCFlags function to set QC Flags for probes that appear to 
be outliers in the data

##### Set Biological Probe QC flags using default settings from DSPDA

```{r setbioprobeqcflag,  eval = TRUE}
demoData <- setBioProbeQCFlags(demoData, 
                               qcCutoffs=list(minProbeRatio=0.1,
                                              percentFailGrubbs=20))
```

##### Check Results

```{r}
head(fData(demoData)[["QCFlags"]])

ProbeQCResults <- fData(demoData)[["QCFlags"]]
ProbeQCData <- as.data.frame(ProbeQCResults)
ProbeQCResults$medianCounts <- apply(assayDataElement(demoData, elt="exprs"),
                                     MARGIN=1, FUN=median)
ProbeQCResults$totalCounts <- apply(assayDataElement(demoData, elt="exprs"),
                                    MARGIN=1, FUN=sum)
ProbeQCResults$totalProbeGeoMean <- apply(assayDataElement(demoData, elt="exprs"),
                                          MARGIN=1, FUN=ngeoMean)

#Flag sample as PASS or WARNING if sample has a QC flag
ProbeQCResults$outlierStatus <- apply(fData(demoData)[["QCFlags"]], 1L, 
                                      function(x) {
                                        y <- sum(x) == 0L
                                        y <- ifelse(y, "PASS", "WARNING")
                                        return(y)}
                                      )
# Append relevant variables to the the QC results dataframe
ProbeQCResults <- cbind(ProbeQCResults, fData(demoData)[c("ProbeRatio", "TargetName")])
ProbeQCResults[1:5, ]
dim(ProbeQCResults)


# Check which probes have outliers
outlierRatio <- subset(demoData, fData(demoData)[["QCFlags"]][,"LowProbeRatio"]== TRUE)
dim(outlierRatio)
outlierGrubbs <- subset(demoData, fData(demoData)[["QCFlags"]][,"GrubbsOutlier"]== TRUE)
dim(outlierGrubbs)
outliersQC <- subset(demoData, 
                     fData(demoData)[["QCFlags"]][,c("LowProbeRatio")]== TRUE |
                       fData(demoData)[["QCFlags"]][,c("GrubbsOutlier")]== TRUE)

# Total Number of probes
length(featureData(demoData)[["ProbeID"]])

# Total Number of probes passed
length(featureData(outliersQC)[["ProbeID"]])

# local outliers
length(featureData(outlierRatio)[["ProbeID"]])

# global outliers
length(featureData(outlierGrubbs)[["ProbeID"]])

```

##### Update cutoffs for Biological Probe QC

```{r setbioprobeqcflagupdated,  eval = TRUE}
demoData <- setBioProbeQCFlags(demoData,
                               qcCutoffs=list(minProbeRatio=0.1,                      
                                              percentFailGrubbs=20))
```

##### Exclude targets that did not pass Biological Probe QC

```{r}  
#Subset object to exclude all that did not pass Bioprobe QC
ProbeQCResultsIndex <- which(apply(fData(demoData)[["QCFlags"]], 1L , 
                                   function(x) sum(x) == 0L))
ProbeQCPassed <- demoData[ProbeQCResultsIndex,]
dim(ProbeQCPassed) 
```

## Collapse to Target

##### AggregateCounts function
After cleaning the object from low counts, the counts can be collapsed to Target 
using aggregateCounts function.

```{r, eval = TRUE}
#demoData <- ProbeQCPassed
# Check how many unique targets the object has
length(unique(featureData(demoData)[["TargetName"]]))

# collapse to targets
target_demoData <- aggregateCounts(demoData)
dim(target_demoData)
exprs(target_demoData)[1:5, 1:5]
```

## Normalization
There is also a preloaded GeoMx DSP-DA Normalization that comes with the 
NanoStringGeoMxSet class. This includes the options to normalize on quantile, 
housekeeping or negative normalization.

```{r normalizeObject, eval = TRUE}
target_demoData <- normalize(target_demoData , data_type="RNA", norm_method="quant", 
                      desiredQuantile = .9, toElt = "q_norm")
target_demoData <- normalize(target_demoData , data_type="RNA", norm_method="neg", 
                             fromElt="exprs",  toElt="neg_norm")
target_demoData <- normalize(target_demoData , data_type="RNA", norm_method="hk", 
                             fromElt="exprs", toElt="hk_norm")
assayDataElement( target_demoData , elt = "q_norm" )[1:3, 1:2]
assayDataElement( target_demoData , elt = "hk_norm" )[1:3, 1:2]
assayDataElement( target_demoData , elt = "neg_norm" )[1:3, 1:2]
```

#### Normalization Plots
To help you decide which is the best normalization to use, you can plot the 
normalization factors using heatmap option in the autoplot function

```{r normalizePlot, fig.width=5, fig.height=4, eval = FALSE}
# Run to generate plots to compare normalization heatmap 
p_qnorm <- autoplot(target_demoData, type = "heatmap-genes",  elt = "q_norm",
                        log2scale = FALSE, heatmapGroup = c("class", "pathology", "region")
                       )
p_negnorm <- autoplot(target_demoData, type = "heatmap-genes",  elt = "neg_norm",
                        log2scale = FALSE, heatmapGroup = c("class", "pathology", "region")
                        )

#p_qnorm
```




```{r}
sessionInfo()
```
