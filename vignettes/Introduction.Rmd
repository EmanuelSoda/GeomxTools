---
title: "Introduction to the NanoStringGeoMxSet Class"
author: "David Henderson, Patrick Aboyoun, Nicole Ortogero, Zhi Yang, Jason Reeves, Kara Gorman, Rona Vitancol, Thomas Smith, Maddy Griswold"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to the NanoStringGeoMxSet Class}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 5,
  fig.height = 4,
  dpi=200
)
```

## Introduction

The NanoStringGeoMxSet was inherited from Biobase's ExpressionSet class. The NanoStringGeoMxSet class was designed to encapsulate data and corresponding methods for NanoString DCC files generated from the NanoString GeoMx 
Digital Spatial Profiling (DSP) platform.


## Loading Packages

Loading the NanoStringNCTools and GeoMxTools packages allow users access to the NanoStringGeoMxSet class and corresponding methods.

```{r, message=FALSE, warning=FALSE}
library(NanoStringNCTools)
library(GeomxTools)
## RV remove this after checking container
library(EnvStats)
library(ggiraph)
```

## Building a NanoStringGeoMxSet from .DCC files 

```{r buildobject}
datadir <- system.file("extdata", "DSP_NGS_Example_Data",
                       package="GeomxTools")
DCCFiles <- dir(datadir, pattern=".dcc$", full.names=TRUE)
PKCFiles <- unzip(zipfile = file.path(datadir,  "/pkcs.zip"))
SampleAnnotationFile <- file.path(datadir, "annotations.xlsx")

demoData <-
  suppressWarnings(readNanoStringGeoMxSet(dccFiles = DCCFiles,
                                          pkcFiles = PKCFiles,
                                          phenoDataFile = SampleAnnotationFile,
                                          phenoDataSheet = "CW005",
                                          phenoDataDccColName = "Sample_ID",
                                          protocolDataColNames = c("aoi",
                                                                   "cell_line",
                                                                   "roi_rep",
                                                                   "pool_rep",
                                                                   "slide_rep"),
                                          experimentDataColNames = c("panel")))
class( demoData )
isS4( demoData )
is( demoData, "ExpressionSet" )
demoData
```


## Accessing and Assigning NanoStringGeoMxSet Data Members

Alongside the accessors associated with the ExpressionSet class, NanoStringGeoMxSet objects have unique additional assignment and accessor methods faciliting common ways to view DSP data and associated labels.

```{r accessobject}
head( pData( demoData ), 2 )
protocolData( demoData )
svarLabels( demoData )
head( sData(demoData), 2 )
```

Design information can be assigned to the NanoStringGeoMxSet object, as well as feature and sample labels to use for NanoStringGeoMxSet plotting methods.

```{r assigndesign}
design( demoData ) <- ~ `segments`
design( demoData )

dimLabels( demoData )
dimLabels( demoData )[2] <- "Sample ID"
dimLabels( demoData )
```

## Summarizing NanoString GeoMx Data

Easily summarize count results using the summary method. Data summaries can be generated across features or samples. Labels can be used to generate summaries based on feature or sample groupings.

```{r summaryobject}
head( summary( demoData , MARGIN = 1 ), 2 )
head( summary( demoData , MARGIN = 2 ), 2 )
unique( sData( demoData )$"cell_line" )
head( summary( demoData , MARGIN = 2, GROUP = "cell_line" )$"HS578T", 2 )
head( summary( demoData , MARGIN = 2, GROUP = "cell_line" )$"COLO201", 2 )
head( summary( demoData , MARGIN = 2, GROUP = "cell_line", log2 = FALSE )$"COLO201", 2 )
```
## Subsetting NanoStringGeoMxSet Objects

Common subsetting methods including those to separate endogenous features from controls are provided with NanoStringGeoMxSet objects. In addition, users can use the subset or select arguments to further subset by feature or sample, respectively.

```{r subsetobject}
## RV Remove once CodeClass iss34 is closed
if (is.null(featureData(demoData)[["CodeClass"]]) & !(is.null(featureData(demoData)[["Codeclass"]])))
    featureData(demoData)[["CodeClass"]] <- featureData(demoData)[["Codeclass"]]  

length( sampleNames( demoData ) )
length( sampleNames( subset( demoData , 
                             select = phenoData( demoData )[["slide name"]] == "6panel-old-slide1 (PTL-10891)" ) ) )

dim( exprs( demoData ) )
dim(demoData[, demoData$`slide name` == "6panel-old-slide1 (PTL-10891)"])
dim(subset(demoData, TargetName == "ACTA2", `slide name` == "6panel-old-slide1 (PTL-10891)"))
dim(subset(demoData, CodeClass == "Control", `slide name` == "6panel-old-slide1 (PTL-10891)"))
dim( exprs( endogenousSubset( demoData, 
                              select = phenoData( demoData )[["slide name"]] == "6panel-old-slide1 (PTL-10891)" ) ) )

with( endogenousSubset( demoData ) , table( `slide name` ) )
with( demoData [1:10, 1:10] , table(cell_line) )    
with( negativeControlSubset( demoData ) , table( CodeClass ) )

## RV uncomment when iss8 control subset is closed
## with( controlSubset( demoData ) , table( CodeClass ) )
## with( nonControlSubset( demoData ) , table( CodeClass ) )
```


## Apply Functions Across Assay Data

Similar to the ExpressionSet's esApply function, an equivalent method is available with NanoStringGeoMxSet objects. Functions can be applied to assay data feature- or sample-wise.

```{r applyFunctions}
assayDataElement( demoData, "demoElem" ) <- 
  assayDataApply( demoData, MARGIN=2, FUN=log, base=10, elt="exprs" )
assayDataElement( demoData, "demoElem" )[1:3, 1:2]
assayDataApply( demoData, MARGIN=1, FUN=mean, elt="demoElem")[1:5]

head( esBy( demoData, 
            GROUP = "cell_line", 
            FUN = function( x ) { 
              assayDataApply( x, MARGIN = 1, FUN=mean, elt="demoElem" ) 
            } ) )
```
## Built-in Quality Control Assessment

Users can flag samples that fail QC thresholds or have borderline results based on expression. 

The setQC Flags will set the QC flags in the protocolData for the samples and probes that are low in count and saturation levels. It will also set flags for probe local outliers (low and high) and Global Outliers
```{r qcobject}
demoData <- setQCFlags(demoData)
demoData@featureData@data[["QCFlags"]][1:2, 1:4]
dim(subset(demoData, QCFlags[["LowProbeRatio"]] == TRUE))
dim(subset(demoData, QCFlags[["LowProbeCount"]] == TRUE))
dim(subset(demoData, QCFlags[["GlobalOutlier"]] == TRUE))
```
Probes and Samples that were flagged can be removed from analysis useing checkQCFlags function. 

```{r removeQCSampleProbe}
dim(demoData)
demoData<- checkQCFlags(demoData, removeLowLocalOutliers = FALSE)
dim(demoData)
```

After cleaning the iobject from low counts, the counts can be collapsed to Target using aggregateCounts function.

```{r}
exprs(demoData)[1:5, 1:5]
demoData <- aggregateCounts(demoData)
dim(demoData)
exprs(demoData)[1:5, 1:5]
```

## Normalization
There is also a preloaded GeoMx DSP-DA Normalization that comes with the NanoStringGeoMxSet class. This includes the options to normalize on quantile, housekeeping or negative normalization.

```{r normalizeObject}
demoData <- normalize(demoData , data_type="RNA", norm_method="quant", desiredQuantile = .9)
demoData <- normalize(demoData , data_type="RNA", norm_method="neg", fromElt="exprs")
demoData <- normalize(demoData , data_type="RNA", norm_method="hk", fromElt="exprs")
assayDataElement( demoData , elt = "q_norm" )[1:3, 1:2]
assayDataElement( demoData , elt = "hk_norm" )[1:3, 1:2]
assayDataElement( demoData , elt = "neg_norm" )[1:3, 1:2]
```

## Normalization Plots
To help you decide which is the best normalization to use, you can plot the normalization factors using heatmap option in the autoplot function

```{r normalizePlot, fig.width=5, fig.height=4}
# Run to generate plots to compare normalization heatmap 
p_qnorm <- autoplot(demoData, type = "heatmap-genes",  elt = "q_norm",
                        log2scale = FALSE, heatmapGroup = c("cell_line", "segment")
                        )
#p_negnorm <- autoplot(demoData, type = "heatmap-genes",  elt = "neg_norm",
#                        log2scale = FALSE, heatmapGroup = c("cell_line", "segment")
#                        )

p_qnorm

```



## Transforming NanoStringRCCSet Data to Data Frames

The NanoStringGeoMxSet munge function helps users generate data frames for downstream modeling and visualization. There is also a transform method, which functions similarly to the base transform function.

```{r muneObject}
neg_set <- negativeControlSubset( demoData )
class( neg_set )
neg_ctrls <- munge( neg_set, ~ exprs)
head( neg_ctrls, 2 )
class( neg_ctrls )
head( munge( demoData, ~ exprs ), 2 )
munge( demoData, mapping = ~`cell_line` + GeneMatrix )
exprs_df <- transform(assayDataElement(demoData, elt = "q_norm"))
class(exprs_df)
exprs_df[1:3, 1:2]
```



## Data exploration

Further data exploration can be performed by visualizing a select feature's expression or by getting a bird's eye view with expression heatmaps auto-generated with unsupervised clustering dendrograms.



```{r}
sessionInfo()
```
