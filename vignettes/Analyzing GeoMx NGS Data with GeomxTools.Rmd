---
title: "Analyzing GeoMx NGS Data with GeomxTools"
author: "David Henderson, Patrick Aboyoun, Nicole Ortogero, Zhi Yang, Jason Reeves, Kara Gorman, Rona Vitancol, Thomas Smith, Maddy Griswold"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to the NanoStringGeoMxSet Class}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 5,
  fig.height = 4,
  dpi=200
)
```

## Introduction

Basic task when analyzing GeoMx NGS dataset outside the Digital Spatial Profiling Data Analysis (DSPDA) is to read the DCC files, PKC files, annotation file and  convert them to an object that allows user to perform their own analysis. GeomxTools gives users the capability to read these GeoMx output and perform  quality control and use the output to proceed with their own analysis pipeline.  

GeomxTools convert the DCC, PKC and annotation file to a NanoStringGeoMxSet which inherits functionality from Biobase's ExpressionSet class. The NanoStringGeoMxSet class was designed to encapsulate data and corresponding methods for NanoString DCC files generated from the NanoString GeoMx Digital Spatial Profiling (DSP) platform.

## Dataset Introduction
For this demo analysis, we will use the kidney dataset that can be found here:
NanoString GeoMx DSP dataset of diabetic kidney disease (DKD) vs healthy kidney tissue. Seven slides were analyzed, 4 DKD and 3 healthy. Regions of Interest (ROI) were focused two different parts of a kidneyâ€™s structure: tubules or glomeruli. One glomerulus ROI contains the entirety of a glomerulus. Individual glomeruli were identified by a pathologist as either behaving relatively healthy or diseased regardless on if the tissue was DKD or healthy. Tubule ROIs were segmented into distal (PanCK) and proximal (neg) tubules. While both distal and proximal tubules are called tubules, they perform very different functions in the kidney. Segmented areas of an ROI are called Areas of Interest (AOI).


## Loading GeomxTools Packages and calling libraries

First step in using the GeomxTools package is to install the package and save it library

```{r, message=FALSE, warning=FALSE }
#devtools::install_github("Nanostring-Biostats/GeomxTools", 
#                         build_vignettes = TRUE, ref = "dev")

library(NanoStringNCTools)
library(GeomxTools)
## RV remove this after checking container
library(EnvStats)
library(ggiraph)
```

## Load DCC files, PKC files and annotation file
Next step is to load the DCC, PKC and annotation file
Save your DCC files in one folder for easy access and save set this location as your datadir below.
```{r, quickstart, message=FALSE, warning=FALSE}
datadir <- file.path( "/home" , "rstudio" , "NAS_data", "szimmerman", "kidney_demo")
DCCFiles <- list.files(file.path( datadir , "DCC_files"), pattern=".dcc$", full.names=TRUE)
PKCFiles <- list.files(file.path(datadir), pattern=".pkc$", full.names=TRUE)
SampleAnnotationFile <- file.path(datadir, "kidney_demo_AOI_Annotations.xlsx")

demoData <-
  suppressWarnings(readNanoStringGeoMxSet(dccFiles = DCCFiles,
                                          pkcFiles = PKCFiles,
                                          phenoDataFile = SampleAnnotationFile,
                                          phenoDataSheet = "Template",
                                          phenoDataDccColName = c("Sample_ID",
                                                                  "pathology", 
                                                                  "class"),
                                          protocolDataColNames = c("aoi", 
                                                                   "roi",
                                                                   "slide_name"),
                                          experimentDataColNames = c("panel")))
```

## Checking the NanoStringGeoMxSet object
Note structure of the resulting demoData object. It contains the following Slots which contains the information from your data.
assayData - contains the expression of targets (either probes or genes) for each sample information. 
protocolData - 
phenoData - contains information on your sample
featureData - contains information for each target
expermentData
Annotation
signature
feature


```{r}
demoData

```

## Accessing and Assigning NanoStringGeoMxSet Data Members

Alongside the accessors associated with the ExpressionSet class, NanoStringGeoMxSet objects have unique additional assignment and accessor methods faciliting common ways to view DSP data and associated labels.

To view your initial data set BioProbeCountMatrix

```{r countmatrix, eval = FALSE}
head(assayData(demoData)[["exprs"]])
head( pData( demoData ), 2 )
protocolData( demoData )
svarLabels( demoData )
head( sData(demoData), 2 )
```

```{r accessobject, eval = FALSE}
head( pData( demoData ), 2 )
protocolData( demoData )
svarLabels( demoData )
head( sData(demoData), 2 )
```

## Quality Control Assessment

Users can flag samples that fail QC thresholds or have borderline results based on expression. This is similar to QC in DSPDA

The setQC Flags will set the QC flags in the protocolData for the samples and probes that are low in count and saturation levels. It will also set flags for probe local outliers (low and high) and Global Outliers

```{r setDefaults,  eval = TRUE}
DEFAULTS <- list(minSegmentReads=1000, # Raw Read threshold
                 percentTrimmed=80, 
                 percentStitched=80, 
                 percentAligned=80, # Percent Aligned Reads
                 percentSaturation=50, # Sequencing Saturation
                 minNegativeCount=10, #Negative probe count geomean
                 maxNTCCount=60,  # No template Control Count
                 minNuclei=16000, # Minimum nuclei count
                #DSP Parameters
                 minArea=20, # minimum surface area
                 minProbeCount=10, 
                 minProbeRatio=0.1, #geomean proble in all segments/geomean probe within target
                 outlierTestAlpha=0.01, 
                 percentFailGrubbs=20, #fails Grubbs outlier test in greater than /% segments
                 loqCutoff=1.0, #LOQ standard deviation
                 highCountCutoff=10000)
```

### Segment QC

#### Technical Signal QC  Set Sequencing QC flags using default settings from DSPDA
Use the setSeqQCFlags  function to set Sequencing QC Flags to your dataset.

```{r setqcflag,  eval = TRUE}
demoData <- setSeqQCFlags(demoData)

#Check Results
head(protocolData(demoData)[["QCFlags"]])

prData <- protocolData(demoData)
QCResults <- prData[["QCFlags"]]
QCResults <- as.data.frame(QCResults)

#Flag sample as PASS or WARNING if sample has a QC flag
QCResults$QCStatus <- apply(prData[["QCFlags"]], 1L, function(x) {
        y <- sum(x) == 0L
        y <- ifelse(y, "PASS", "WARNING")
        return(y)
    })
QCResults

# Check which samples have low reads
LowReads <- subset(demoData, select= prData[["QCFlags"]][,"LowReads"] == TRUE)
sData(LowReads)["Raw"]
QCResults[rownames(sData(LowReads)),]

# Check which samples are below Sequencing Saturation cutoff
LowSaturation <- subset(demoData, select= prData[["QCFlags"]][,"LowSaturation"] == TRUE)
sData(LowSaturation)[c("DeduplicatedReads", "Aligned")]
sData(LowSaturation)[c("DeduplicatedReads", "Aligned")]
QCResults[rownames(sData(LowSaturation)),]
```

##### Set QC flags Update cutoffs
```{r setqcflagupdated,  eval = TRUE}
demoData <- setSeqQCFlags(demoData, 
                       qcCutoffs=list(minSegmentReads=1000,
                                      percentAligned=80,
                                      percentSaturation=.50))
# Subset object to exclude all that did not pass Sequencing QC
QCResultsIndex <- which(apply(prData[["QCFlags"]], 1L , function(x) sum(x) == 0L))
QCPassed <- demoData[, QCResultsIndex]
dim(QCPassed) 
```


#### Technical background QC: Set Background QC flags using default settings from DSPDA
Use the setBackgroundQCFlags function to set background QC Flags to your dataset.

```{r setbgqcflag,  eval = TRUE}
demoData <- setBackgroundQCFlags(demoData)

#Check Results
head(protocolData(demoData)[["QCFlags"]])

prData <- protocolData(demoData)
QCResults <- prData[["QCFlags"]]
QCResults <- as.data.frame(QCResults)

#Flag sample as PASS or WARNING if sample has a QC flag
QCResults$QCStatus <- apply(prData[["QCFlags"]], 1L, function(x) {
        y <- sum(x) == 0L
        y <- ifelse(y, "PASS", "WARNING")
        return(y)
    })
QCResults

# Check which samples have low negative geomean
lowNegatives <- subset(demoData, select= prData[["QCFlags"]][,"lowNegatives"] == TRUE)
sampleNames(phenoData(lowNegatives))

#Check expression of negative probes for failing samples
exprs(negativeControlSubset(lowNegatives))
dim(negativeControlSubset(lowNegatives))


# Check which samples are below Sequencing Saturation cutoff
LowSaturation <- subset(demoData, select= prData[["QCFlags"]][,"LowSaturation"] == TRUE)
sData(LowSaturation)[c("DeduplicatedReads", "Aligned")]
sData(LowSaturation)[c("DeduplicatedReads", "Aligned")]
QCResults[rownames(sData(LowSaturation)),]
```

##### Set Background QC flags Update cutoffs
```{r setbgqcflagupdated,  eval = TRUE}
demoData <- setBackgroundQCFlags(demoData, 
                  qcCutoffs=list(minNegativeCount=5, 
                                 maxNTCCount=10))
# Subset object to exclude all that did not pass Sequencing QC
QCResultsIndex <- which(apply(prData[["QCFlags"]], 1L , function(x) sum(x) == 0L))
QCPassed <- demoData[, QCResultsIndex]
dim(QCPassed) 
```


#### DSP Parameters Minimum Nuclei and Surface Area Count QC  
Set Segment QC flags using default settings from DSPDA
Use the setGeoMxQCFlags function to set segment QC Flags to your dataset.

```{r setsegmentqcflag,  eval = TRUE}
demoData <- setGeoMxQCFlags(demoData)

#Check Results
head(protocolData(demoData)[["QCFlags"]])

prData <- protocolData(demoData)
QCResults <- prData[["QCFlags"]]
QCResults <- as.data.frame(QCResults)

#Flag sample as PASS or WARNING if sample has a QC flag
QCResults$QCStatus <- apply(prData[["QCFlags"]], 1L, function(x) {
        y <- sum(x) == 0L
        y <- ifelse(y, "PASS", "WARNING")
        return(y)
    })
QCResults

# Check which samples have low area
lowArea <- subset(demoData, select= prData[["QCFlags"]][,"lowArea"]== TRUE)
sData(lowArea)["area"]

# Check which samples have low nuclei

```

##### Set Segement QC flags Update cutoffs

```{r setsegmentqcflagupdated,  eval = TRUE}
demoData <- setGeoMxQCFlags(demoData, 
                            qcCutoffs=list(minNuclei=16000, 
                                           minArea=20))
# Subset object to exclude all that did not pass Sequencing QC
QCResultsIndex <- which(apply(prData[["QCFlags"]], 1L , function(x) sum(x) == 0L))
QCPassed <- demoData[, QCResultsIndex]
dim(QCPassed) 
```



### Biological Probe QC 
Use the setBioProbeQCFlags function to set QC Flags for probes that appear to be outliers in the data

#### Set Biological Probe QC flags using default settings from DSPDA

```{r setbioprobeqcflag,  eval = TRUE}
demoData <- setBioProbeQCFlags(demoData)

#Check Results
head(fData(demoData)[["QCFlags"]])
summary(demoData)

ProbeQCResults <- fData(demoData)[["QCFlags"]]
ProbeQCData <- as.data.frame(ProbeQCResults)
ProbeQCResults$medianCounts <- apply(assayDataElement(demoData, elt="exprs"),MARGIN=1, FUN=median)
ProbeQCResults$totalCounts <- apply(assayDataElement(demoData, elt="exprs"),MARGIN=1, FUN=sum)
ProbeQCResults$totalProbeGeoMean <- apply(assayDataElement(demoData, elt="exprs"),MARGIN=1, FUN=ngeoMean)

#Flag sample as PASS or WARNING if sample has a QC flag
ProbeQCResults$outlierStatus <- apply(fData(demoData)[["QCFlags"]], 1L, function(x) {
        y <- sum(x) == 0L
        y <- ifelse(y, "PASS", "WARNING")
        return(y)
    })
ProbeQCResults

# Check which probes have outliers
outlierRatio <- subset(demoData, fData(demoData)[["QCFlags"]][,"LowProbeRatio"]== TRUE)
outlierGrubbs <- subset(demoData, fData(demoData)[["QCFlags"]][,"LowProbeRatio"]== TRUE)

```

##### Set Segement QC flags Update cutoffs
```{r setbioprobeqcflagupdated,  eval = TRUE}
demoData <- setBioProbeQCFlags(demoData,
                               qcCutoffs=list(minProbeRatio=0.1,                      
                                              percentFailGrubbs=20))
  
#Subset object to exclude all that did not pass Sequencing QC
ProbeQCResultsIndex <- which(apply(fData(demoData)[["QCFlags"]], 1L , function(x) sum(x) == 0L))
ProbeQCPassed <- demoData[ProbeQCResultsIndex,]
dim(ProbeQCPassed) 
```

Probes and Samples that were flagged can be removed from analysis using checkQCFlags function. 


```{r removeQCSampleProbe, eval = FALSE}
dim(demoData)
demoData<- checkQCFlags(demoData, removeLowLocalOutliers = FALSE)
dim(demoData)
```

After cleaning the iobject from low counts, the counts can be collapsed to Target using aggregateCounts function.

```{r, eval = FALSE}
exprs(demoData)[1:5, 1:5]
demoData <- aggregateCounts(demoData)
dim(demoData)
exprs(demoData)[1:5, 1:5]
```

## Normalization
There is also a preloaded GeoMx DSP-DA Normalization that comes with the NanoStringGeoMxSet class. This includes the options to normalize on quantile, housekeeping or negative normalization.

```{r normalizeObject, eval = FALSE}
demoData <- normalize(demoData , data_type="RNA", norm_method="quant", desiredQuantile = .9, toElt = "q_norm")
demoData <- normalize(demoData , data_type="RNA", norm_method="neg", fromElt="exprs",  toElt="neg_norm")
demoData <- normalize(demoData , data_type="RNA", norm_method="hk", fromElt="exprs", toElt="hk_norm")
assayDataElement( demoData , elt = "q_norm" )[1:3, 1:2]
assayDataElement( demoData , elt = "hk_norm" )[1:3, 1:2]
assayDataElement( demoData , elt = "neg_norm" )[1:3, 1:2]
```

## Normalization Plots
To help you decide which is the best normalization to use, you can plot the normalization factors using heatmap option in the autoplot function

```{r normalizePlot, fig.width=5, fig.height=4, eval = FALSE}
# Run to generate plots to compare normalization heatmap 
p_qnorm <- autoplot(demoData, type = "heatmap-genes",  elt = "q_norm",
                        log2scale = FALSE, heatmapGroup = c("cell_line", "segment")
                       )
p_negnorm <- autoplot(demoData, type = "heatmap-genes",  elt = "neg_norm",
                        log2scale = FALSE, heatmapGroup = c("cell_line", "segment")
                        )

p_qnorm

```



## Transforming NanoStringRCCSet Data to Data Frames

The NanoStringGeoMxSet munge function helps users generate data frames for downstream modeling and visualization. There is also a transform method, which functions similarly to the base transform function.

```{r mungeObject, eval = FALSE}
neg_set <- negativeControlSubset( demoData )
class( neg_set )
neg_ctrls <- munge( neg_set, ~ exprs)
head( neg_ctrls, 2 )
class( neg_ctrls )
head( munge( demoData, ~ exprs ), 2 )
munge( demoData, mapping = ~`cell_line` + GeneMatrix )
exprs_df <- transform(assayDataElement(demoData, elt = "q_norm"))
class(exprs_df)
exprs_df[1:3, 1:2]
```



## Data exploration

Further data exploration can be performed by visualizing a select feature's expression or by getting a bird's eye view with expression heatmaps auto-generated with unsupervised clustering dendrograms.



```{r}
sessionInfo()
```
