---
title: "Protein data using GeomxTools"
output:
  html_document:
    theme: united
    df_print: kable
  pdf_document: default
date: 'Compiled: `r Sys.Date()`'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  message = FALSE,
  warning = FALSE,
  fig.width = 10
)
```

# Overview

This tutorial demonstrates how to use GeomxTools for preprocessing protein or proteogenomics data. 

# Data Processing

Data processing is very similar to what is shown in the [Developer_Introduction_to_the_NanoStringGeoMxSet vignette](http://www.bioconductor.org/packages/release/bioc/vignettes/GeomxTools/inst/doc/Developer_Introduction_to_the_NanoStringGeoMxSet.html) with a couple of protein specific functions.  

```{r Load Libraries}
library(GeomxTools)
```

GeoMxSet objects can only read in one analyte at a time. With protein or proteogenomics data, the desired analyte must be added to the call to read in the object. RNA is the default analyte. 
```{r Read in Data}
datadir <- system.file("extdata","DSP_Proteogenomics_Example_Data",
                       package = "GeomxTools")

DCCFiles <- unzip(zipfile = file.path(datadir,  "/DCCs.zip"))
PKCFiles <- unzip(zipfile = file.path(datadir,  "/pkcs.zip"))
SampleAnnotationFile <- file.path(datadir, "Annotation.xlsx")


RNAData <- suppressWarnings(readNanoStringGeoMxSet(dccFiles = DCCFiles,
                                                   pkcFiles = PKCFiles,
                                                   phenoDataFile = SampleAnnotationFile,
                                                   phenoDataSheet = "Annotations",
                                                   phenoDataDccColName = "Sample_ID",
                                                   protocolDataColNames = c("Tissue", 
                                                                            "Segment_Type", 
                                                                            "ROI.Size"),
                                                   configFile = NULL,
                                                   analyte = "RNA",
                                                   phenoDataColPrefix = "",
                                                   experimentDataColNames = NULL))

proteinData <- suppressWarnings(readNanoStringGeoMxSet(dccFiles = DCCFiles,
                                                       pkcFiles = PKCFiles,
                                                       phenoDataFile = SampleAnnotationFile,
                                                       phenoDataSheet = "Annotations",
                                                       phenoDataDccColName = "Sample_ID",
                                                       protocolDataColNames = c("Tissue", 
                                                                                "Segment_Type", 
                                                                                "ROI.Size"),
                                                       configFile = NULL,
                                                       analyte = "protein",
                                                       phenoDataColPrefix = "",
                                                       experimentDataColNames = NULL))

RNAData <- aggregateCounts(RNAData)
RNAData

proteinData <- aggregateCounts(proteinData)
proteinData
```

By having the datasets split by analyte, each object can go through the typical QC and normalization steps specific to that analyte. 


# RNA
For RNA please refer to the [introduction vignette](http://www.bioconductor.org/packages/release/bioc/vignettes/GeomxTools/inst/doc/Developer_Introduction_to_the_NanoStringGeoMxSet.html). 

# Protein 

### Segment QC
After reading in the object, we will do one QC step: flag and remove low quality ROIs 

```{r GeomxTools QC}
proteinData <- setSegmentQCFlags(proteinData, qcCutoffs = list(percentSaturation = 45))

# low sequenced ROIs
lowSaturation <- which(as.data.frame(protocolData(proteinData)[["QCFlags"]])["LowSaturation"] == TRUE)

# remove low quality ROIs
passedQC <- proteinData[, -lowSaturation]
dim(proteinData)
dim(passedQC)
```
### Target QC

Housekeepers and the IgGs from a dataset can easily be pulled out of the dataset. 

```{r HK and IgGs}
hk.names <- hkNames(proteinData)
hk.names

igg.names <- iggNames(proteinData)
igg.names
```

For the target QC step, we identify proteins will no useful signal using this figure. 
```{r target QC, fig.width= 16, fig.height=7}
proteinOrder <- qcProteinSignal(object = proteinData, neg.names = igg.names)
```

  -	IgGs are plotted on the far left of the plot.
  -	Tyrosine Hydroxylase hovers around background in all segments and should probably be excluded from analysis. 
  -	ApoA-I is mostly near-background, but it has meaningfully high signal in a handful of segments. 
  -	EpCAM seems to have lower background than the negative controls. But its long range, and especially the existence of points well above background, suggests this protein has interpretable data. 

To remove proteins we will first pick a protein where all of the proteins to the left of it should be removed from analysis due to low signal. Here we will pick **Tyrosine Hydroxylase** since the protein to the right, **HSC70**, has meaningful signal. And replot the figure without the super low proteins. 

```{r, fig.width= 12, fig.height=7}
length(proteinOrder)

#Right most protein where all proteins to the left will get removed
#start at 4 to keep the 3 IgG targets
proteinOrder <- proteinOrder[-c(4:which(proteinOrder == "Tyrosine Hydroxylase"))]
length(proteinOrder)

#replot with fewer targets
proteinOrder <- qcProteinSignal(object = proteinData[proteinOrder,], neg.names = igg.names)
```

From this figure, we can see that there are a couple more proteins that, due to low signal, should be removed from the analysis. After removing these proteins we will replot again. 
```{r, fig.width= 12, fig.height=7}
#which proteins to remove from analysis
lowTargets <- c("pan-RAS", "Neprilysin", "Olig2", "P2ry12", "p53", "NY-ESO-1", "INPP4B", "CD31", "Phospho-Alpha-synuclein (S129)", "Bcl-2")
proteinOrder <- proteinOrder[-c(which(proteinOrder %in% lowTargets))]
length(proteinOrder)

proteinOrder <- qcProteinSignal(object = proteinData[proteinOrder,], neg.names = igg.names)
```
If there are no more proteins to remove from analysis, we will subset the dataset to only contain the proteins that are above background. 
```{r}
dim(proteinData)
proteinData <- proteinData[proteinOrder,]
dim(proteinData)
```

### Normalization

After filtering targets, we move onto normalization. There are many types of normalization and we have two built in figures to help decide what is the best method for the dataset. 

The first is a concordance plot of a list of targets, normally the IgGs or HK, colored by ROI factors like tissue or segment type. The upper panels are the concordance plots and the lower panels are the standard deviation of the log2-ratios between the targets. Our motivating theory is simple: if several targets all accurately measure signal strength, they should be highly correlated with each other. More precisely, the log-ratios between them should have low SDs.

```{r IgG concordance}
plotConcordance(object = proteinData, targetList = igg.names, plotFactors = "Segment_Type")
plotConcordance(object = proteinData, targetList = igg.names, plotFactors = "Tissue")
```

Above we see good concordance amongst the IgGs, confirming they all can be used. Numbers in the lower-left panels show the SD of the log2-ratios between IgGs. Importantly, we do not see a tendency for one IgG to be offset from the others, suggesting thereâ€™s no between-slide bias in calculation of background.


The second plot helps show the concordance of normalization factors. The factors are calculated on the IgG and HK targets and the area or nuclei count if provided. The upper panels are the concordance plots and the lower panels are the standard deviation of the log2-ratios between the normalization factors.

```{r norm concordance}
normfactors <- computeNormalizationFactors(object = proteinData,
                                           area = "AOI.Size.um2",
                                           nuclei = "Nuclei.Counts")

plotNormFactorConcordance(object = proteinData, plotFactors = "Segment_Type",
                          normfactors = normfactors)
```

From this plot we can conclude that:

  -	The IgGs and the housekeepers agree nicely, suggesting that if we normalize using one of them, the other will leave little artifactual signal in the data. If these factors diverged strongly, we would know that normalization with one of them would fail to account to the other, leaving an artifact in the data that must be accounted for in downstream analysis. 
  -	Area and nuclei are consistent with each other (SD log2 ratio of 0.61). 
  -	Area and nuclei diverge somewhat from the target-based normalization factors Neg geomean and HK geomean. This suggests that signal strength is not purely a result of area/cell count, or alternatively, that the neg and HK geomeans are noisy metrics. 
  -	The concordance of Negs/HKs suggests their performance is adequate, leading to the conclusion that area/nuclei are noisy measurements of signal strength in this data. 


After choosing a normalization technique from these plots, we normalize the data. Area and nuclei normalization are not native functions in GeomxTools, if you decide on normalizing by those factors you will need to do that separately. 

```{r GeomxTools Normalization}
#HK normalization
proteinData <- normalize(proteinData, norm_method="hk", toElt = "hk_norm")

#Negative normalization
proteinData <- normalize(proteinData, norm_method="neg", toElt = "neg_norm")

#Quantile normalization
proteinData <- normalize(proteinData, norm_method="quant", desiredQuantile = .75, toElt = "q_norm")

names(proteinData@assayData)
```

This dataset is now ready for downstream analysis. 

```{r}
sessionInfo()
```
